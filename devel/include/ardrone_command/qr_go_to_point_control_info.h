// Generated by gencpp from file ardrone_command/qr_go_to_point_control_info.msg
// DO NOT EDIT!


#ifndef ARDRONE_COMMAND_MESSAGE_QR_GO_TO_POINT_CONTROL_INFO_H
#define ARDRONE_COMMAND_MESSAGE_QR_GO_TO_POINT_CONTROL_INFO_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace ardrone_command
{
template <class ContainerAllocator>
struct qr_go_to_point_control_info_
{
  typedef qr_go_to_point_control_info_<ContainerAllocator> Type;

  qr_go_to_point_control_info_()
    : time_stamp()
    , target_point_camera_xyz()
    , target_point_local_xyz()
    , estimated_distance_to_target(0.0)
    , mode(0)
    , qr_x_axis_I_term(0.0)
    , qr_y_axis_I_term(0.0)
    , qr_xyz_throttle()  {
      target_point_camera_xyz.assign(0.0);

      target_point_local_xyz.assign(0.0);

      qr_xyz_throttle.assign(0.0);
  }
  qr_go_to_point_control_info_(const ContainerAllocator& _alloc)
    : time_stamp()
    , target_point_camera_xyz()
    , target_point_local_xyz()
    , estimated_distance_to_target(0.0)
    , mode(0)
    , qr_x_axis_I_term(0.0)
    , qr_y_axis_I_term(0.0)
    , qr_xyz_throttle()  {
      target_point_camera_xyz.assign(0.0);

      target_point_local_xyz.assign(0.0);

      qr_xyz_throttle.assign(0.0);
  }



   typedef ros::Time _time_stamp_type;
  _time_stamp_type time_stamp;

   typedef boost::array<double, 3>  _target_point_camera_xyz_type;
  _target_point_camera_xyz_type target_point_camera_xyz;

   typedef boost::array<double, 3>  _target_point_local_xyz_type;
  _target_point_local_xyz_type target_point_local_xyz;

   typedef double _estimated_distance_to_target_type;
  _estimated_distance_to_target_type estimated_distance_to_target;

   typedef uint32_t _mode_type;
  _mode_type mode;

   typedef double _qr_x_axis_I_term_type;
  _qr_x_axis_I_term_type qr_x_axis_I_term;

   typedef double _qr_y_axis_I_term_type;
  _qr_y_axis_I_term_type qr_y_axis_I_term;

   typedef boost::array<double, 3>  _qr_xyz_throttle_type;
  _qr_xyz_throttle_type qr_xyz_throttle;




  typedef boost::shared_ptr< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> const> ConstPtr;

}; // struct qr_go_to_point_control_info_

typedef ::ardrone_command::qr_go_to_point_control_info_<std::allocator<void> > qr_go_to_point_control_info;

typedef boost::shared_ptr< ::ardrone_command::qr_go_to_point_control_info > qr_go_to_point_control_infoPtr;
typedef boost::shared_ptr< ::ardrone_command::qr_go_to_point_control_info const> qr_go_to_point_control_infoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ardrone_command

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/indigo/share/geometry_msgs/cmake/../msg'], 'ardrone_command': ['/home/ghost/catkin_ws/src/ardrone_command/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3875b1a67eb136919db8696c0841fe5c";
  }

  static const char* value(const ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3875b1a67eb13691ULL;
  static const uint64_t static_value2 = 0x9db8696c0841fe5cULL;
};

template<class ContainerAllocator>
struct DataType< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ardrone_command/qr_go_to_point_control_info";
  }

  static const char* value(const ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#This message is published when the drone is going to a particular point using QR code coordinates.\n\
\n\
time time_stamp\n\
float64[3] target_point_camera_xyz #The estimated position of the target point in the AR drone's camera coordinate system\n\
float64[3] target_point_local_xyz #The estimated position of the target point in the AR drone movement system coordinate system\n\
float64 estimated_distance_to_target\n\
\n\
#The control algorithm has two different PID value sets that it uses.  One is optimized for maintaining position when the drone is close to the point (near) and the other is optimized for getting the drone close to the point without gaining too much speed (far).  The drone switches between these sets based on how far it thinks it is from the target.\n\
\n\
uint32 mode #0 = near, 1 = far\n\
float64 qr_x_axis_I_term #The I part of the PID control for the quadrotor x axis\n\
float64 qr_y_axis_I_term #The I part of the PID control for the quadrotor y axis\n\
\n\
float64[3] qr_xyz_throttle #The final values sent to the AR drone for desired speed in XYZ\n\
\n\
";
  }

  static const char* value(const ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.time_stamp);
      stream.next(m.target_point_camera_xyz);
      stream.next(m.target_point_local_xyz);
      stream.next(m.estimated_distance_to_target);
      stream.next(m.mode);
      stream.next(m.qr_x_axis_I_term);
      stream.next(m.qr_y_axis_I_term);
      stream.next(m.qr_xyz_throttle);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct qr_go_to_point_control_info_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ardrone_command::qr_go_to_point_control_info_<ContainerAllocator>& v)
  {
    s << indent << "time_stamp: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.time_stamp);
    s << indent << "target_point_camera_xyz[]" << std::endl;
    for (size_t i = 0; i < v.target_point_camera_xyz.size(); ++i)
    {
      s << indent << "  target_point_camera_xyz[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_point_camera_xyz[i]);
    }
    s << indent << "target_point_local_xyz[]" << std::endl;
    for (size_t i = 0; i < v.target_point_local_xyz.size(); ++i)
    {
      s << indent << "  target_point_local_xyz[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.target_point_local_xyz[i]);
    }
    s << indent << "estimated_distance_to_target: ";
    Printer<double>::stream(s, indent + "  ", v.estimated_distance_to_target);
    s << indent << "mode: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mode);
    s << indent << "qr_x_axis_I_term: ";
    Printer<double>::stream(s, indent + "  ", v.qr_x_axis_I_term);
    s << indent << "qr_y_axis_I_term: ";
    Printer<double>::stream(s, indent + "  ", v.qr_y_axis_I_term);
    s << indent << "qr_xyz_throttle[]" << std::endl;
    for (size_t i = 0; i < v.qr_xyz_throttle.size(); ++i)
    {
      s << indent << "  qr_xyz_throttle[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.qr_xyz_throttle[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // ARDRONE_COMMAND_MESSAGE_QR_GO_TO_POINT_CONTROL_INFO_H
